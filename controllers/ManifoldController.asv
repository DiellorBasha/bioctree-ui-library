classdef ManifoldController < matlab.ui.componentcontainer.ComponentContainer
    % ManifoldController
    %
    % A minimal, high-performance component that hosts a viewer3d
    % and renders a surface manifold.
    %
    % Responsibilities:
    %   - Render a triangulated surface
    %   - Expose the viewer3d object
    %   - Maintain a Seed vertex index
    %   - Synchronize Seed <-> annotation position
    %
    % This component does NOT:
    %   - Perform file I/O
    %   - Apply spectral kernels
    %   - Interpret Seed semantics beyond geometry

    %% =========================
    %  Public API
    %  =========================

    properties
        % Triangulation representing the manifold
        Triangulation = []

        % Current seed vertex index (1-based)
        Seed (1,1) double = 1
    end

    properties (SetAccess = protected)
        % Expose the viewer publicly (read-only)
        Viewer images.ui.graphics3d.Viewer3D
    end

    %% =========================
    %  Private UI state
    %  =========================

    properties (Access = private, Transient, NonCopyable)
        GridLayout   matlab.ui.container.GridLayout
        ViewerPanel matlab.ui.container.Panel
        SurfaceObj  images.ui.graphics3d.Surface

        % Canonical seed annotation
        SeedAnnotation images.ui.graphics.roi.Point
    end

    events
    SeedChanged
end

    %% =========================
    %  Component lifecycle
    %  =========================

    methods (Access = protected)

        function setup(comp)
            % Root grid
            comp.GridLayout = uigridlayout(comp);
            comp.GridLayout.RowHeight    = {'1x'};
            comp.GridLayout.ColumnWidth = {'1x'};

            % Panel to host viewer3d
            comp.ViewerPanel = uipanel(comp.GridLayout);
            comp.ViewerPanel.Layout.Row    = 1;
            comp.ViewerPanel.Layout.Column = 1;

            % Create viewer3d
            comp.Viewer = viewer3d( ...
                comp.ViewerPanel, ...
                "BackgroundColor", [0 0 0], ...
                "BackgroundGradient", "off", ...
                "RenderingQuality", "high");

            % Sensible default camera
            comp.Viewer.Mode.Default.CameraVector = [-1 -1 1];

            % Listen for interactive annotation events
            addlistener(comp.Viewer, 'AnnotationAdded', ...
                @(~,evt)comp.onAnnotationEvent(evt));

            addlistener(comp.Viewer, 'AnnotationMoved', ...
                @(~,evt)comp.onAnnotationEvent(evt));
        end

        function update(comp)
            % Render or update surface when Triangulation changes

            if isempty(comp.Triangulation)
                return
            end

            if isempty(comp.SurfaceObj) || ~isvalid(comp.SurfaceObj)
                comp.SurfaceObj = images.ui.graphics3d.Surface( ...
                    comp.Viewer, ...
                    'Data', comp.Triangulation, ...
                    'Color', [0.8 0.8 0.8], ...
                    'Alpha', 1, ...
                    'Wireframe', false);
            else
                comp.SurfaceObj.Data = comp.Triangulation;
            end
        end
    end

    %% =========================
    %  Public methods
    %  =========================

    methods

        function setMeshFromVerticesFaces(comp, V, F)
            % Set manifold mesh from vertices and faces

            arguments
                comp
                V (:,3) double
                F (:,3) {mustBeNumeric}
            end

            comp.Triangulation = triangulation(double(F), V);

            % Initialize seed
            comp.Seed = 1;

            % Render and sync annotation
            comp.update();
            comp.syncAnnotationToSeed();
        end

        function setMeshFromTriangulation(comp, tri)
            % Set manifold mesh directly from a triangulation

            arguments
                comp
                tri (1,1) triangulation
            end

            comp.Triangulation = tri;

            % Initialize seed
            comp.Seed = 1;

            % Render and sync annotation
            comp.update();
            comp.syncAnnotationToSeed();
        end

        function clearMesh(comp)
            % Remove the surface and seed annotation

            if ~isempty(comp.SurfaceObj) && isvalid(comp.SurfaceObj)
                delete(comp.SurfaceObj);
            end

            if ~isempty(comp.SeedAnnotation) && isvalid(comp.SeedAnnotation)
                delete(comp.SeedAnnotation);
            end

            comp.SurfaceObj    = [];
            comp.SeedAnnotation = [];
            comp.Triangulation = [];
            comp.Seed = 1;
        end
    end

    %% =========================
    %  Internal logic
    %  =========================

    methods (Access = private)

        function syncAnnotationToSeed(comp)
            % Ensure a point annotation exists at the Seed vertex

            if isempty(comp.Triangulation)
                return
            end

            V = comp.Triangulation.Points;

            if comp.Seed < 1 || comp.Seed > size(V,1)
                return
            end

            pos = V(comp.Seed, :);

            if isempty(comp.SeedAnnotation) || ~isvalid(comp.SeedAnnotation)
                comp.SeedAnnotation = images.ui.graphics.roi.Point( ...
                    'Parent', comp.Viewer, ...
                    'Position', pos);
            else
                % Programmatic move (does not fire AnnotationMoved)
                comp.SeedAnnotation.Position = pos;
            end
        end

        function onAnnotationEvent(comp, evt)
            % Handle AnnotationAdded / AnnotationMoved events
            % Map annotation geometry -> Seed vertex

            if isempty(comp.Triangulation)
                return
            end

            roi = evt.Annotation;
            pos = roi.Position;

            % Defensive checks
            if ~isnumeric(pos) || size(pos,2) ~= 3
                return
            end

            % Handle line annotations by centroid
            if size(pos,1) > 1
                pos = mean(pos, 1);
            end

            pos = double(pos);

            % Map to nearest vertex
            vidx = nearestNeighbor(comp.Triangulation, pos);

            % Update model state
            comp.Seed = vidx;

            % Adopt this ROI as the canonical seed annotation
            comp.SeedAnnotation = roi;
        end
    end
end
